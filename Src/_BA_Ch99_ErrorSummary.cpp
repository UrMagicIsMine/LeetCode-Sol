// Prob2: remember to reset carry;
// Prob3: remember to compare whole length;
// Prob5: loop the whole length;
// Prob8: be careful about leading 0;
// Prob11: Don't forget to use max;
// Prob15: Be careful about the move of idx after find match;
// Prob23: Do not push nullptr to heap;
// Prob28: Be careful about both string could be empty;
// Prob29: 1) all value use long long; 2) Don't forget equal cases;
// Prob30: Be careful about <,<= and >, >=
// Prob38: Be careful about i++/string +=
// Prob54: Be careful about switch direction
// Prob62: Do not overflow array
// Prob70: Do not overflow dp array, allocate (N+1) size
// Prob75: Do not need to care what is in nums[low] and nums[high], regardless
// of whether it's the desired value in this run; take care when nums[i] == 2,
// after swap, nums[i] could be any value, so i--
// Prob91: leading zero, be careful about 02, 10, 20, 27, corner case
// Prob98: INT over flow, LLONG_MIN, LLONG_MAX
// Prob101: be careful about the comparison of two pointer
// Prob125: be careful about logic of orders to compare
// Prob127: use hash table and two end search to optimize
// Prob130: be careful about "=" and "==", index of 2d array
// Prob138: be careful about the case where random point to nullptr
// Prob148: [Important] Spent more time!!!
// Prob139: [Important] Spent more time!!!
// Prob152: [Important] Spent more time!!!
// Prob162: [Important] only compare neighor, spent more time
// Prob166: use long long for all, hashtable for index, consider 0 and sign
// prob172: n/5 + n/25 + n/125 + ...
// prob179: comparator, leading 0
// prob204: two i*i trick, spent more time!!!
// prob207: [Important] put visited mark after complete visit, be careful the index
//          of next node to visit; check path,not visited
// prob208: [Important] spent more time!!!
// prob236: use smart solution !!!
// prob238: use a single left, right value to loop
// prob268: use ^ operator
// prob279: use BFS, visit flag, consider break loop when nextsum > target
// prob300: use lower_bound to build a LIS array
// prob322: DP solution
// prob334: use two number to maintain the two min values
// prob341:
// prob347: hash table and bucket sort
// prob350:
// prob371: use & to get carry and << 1 to advance, use ^ to get preserve,
// prob378:
// prob380: [Important], use hash table and vector to achieve O(1), be careful
//          about the index of hash table
// prob395: [Important], use hash table to count frequency, determine and split
